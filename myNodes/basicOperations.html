<!--getImageDims-->
<script type="text/javascript">
  RED.nodes.registerType('get image dims',{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true}
    },
    inputs:1,
    inputLabels: "img",
    outputs:1,
    outputLabels: "",
    icon: "",
    label: function() {
      return this.name||"get image dims";
    }
  });
</script>

<!--getImageDims-->
<script type="text/html" data-template-name="get image dims">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
</script>

<script type="text/html" data-help-name="get image dims">
  <p>Returns dimensions and color depth info: isGrayscale, shape, numChannels, numDims, colDepth </p>
  <h3>Inputs</h3>
    <ul> <li>payload [img] </ul>
  <h3>Outputs</h3>
    <ol>
      <li>payload.isGrayscale [bool]
      <li>payload.dimensions [tuple]: Contains the width and height of input image
      <li>payload.width [int]
      <li>payload.height[int]
      <li>payload.numChannels: The number of color channels, eg 1 for grayscale, 3 for RGB, 4 for RGBA
      <li>payload.numDims: eg 3 for RGB or RGBA, 2 for grayscale with 1 channel
      <li>payload.colDepth
    </ol>
</script>


<!--changeColorDepth-->
<script type="text/javascript">
  RED.nodes.registerType('change color depth',{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true}
    },
    inputs:1,
    inputLabels: "img",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"change color depth";
    }
  });
</script>

<!--changeColorDepth-->
<script type="text/html" data-template-name="change color depth">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
</script>

<!--changeColorDepth-->
<script type="text/html" data-help-name="change color depth">
  <p> Changes the color depth of any image, to uint8. This is the supported color depth
    by all the nodes of remote-image-processing package.
  </p>
  <h3>Inputs</h3>
    <ul> <li>payload [img] </ul>
  <h3>Outputs</h3>
    <ol><li>payload [img]: Image of color depth uint8. </ol>
</script>


<!--cvtColor-->
<script type="text/javascript">
  RED.nodes.registerType('change color space',{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      colCode: {value: "6"}
    },
    inputs:1,
    inputLabels: "img",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"change color space";
    }
  });
</script>

<!--cvtColor-->
<script type="text/html" data-template-name="change color space">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-colCode"><i class="fa fa-tag"></i> conversion code</label>
    <select id="node-input-colCode">
      <option value="4" id="cvtColor_RGB2BGR">RGB2BGR
      <option value="4" id="cvtColor_BGR2RGB">BGR2RGB
      <option value="6" id="cvtColor_BGR2GRAY">BGR2GRAY
      <option value="7" id="cvtColor_RGB2GRAY">RGB2GRAY
      <option value="2" id="cvtColor_RGBA2RGB">RGBA2RGB
      <option value="8" id="cvtColor_GRAY2BGR">GRAY2BGR
      <option value="8" id="cvtColor_GRAY2RGB">GRAY2RGB
      <option value="32" id="cvtColor_BGR2XYZ">BGR2XYZ
      <option value="33" id="cvtColor_RGB2XYZ">RGB2XYZ
      <option value="34" id="cvtColor_XYZ2BGR">XYZ2BGR
      <option value="35" id="cvtColor_XYZ2RGB">XYZ2RGB
      <option value="36" id="cvtColor_BGR2YCrCb">BGR2YCrCb
      <option value="37" id="cvtColor_RGB2YCrCb">RGB2YCrCb
      <option value="38" id="cvtColor_YCrCb2BGR">YCrCb2BGR
      <option value="39" id="cvtColor_YCrCb2RGB">YCrCb2RGB
      <option value="40" id="cvtColor_BGR2HSV">BGR2HSV
      <option value="41" id="cvtColor_RGB2HSV">RGB2HSV
      <option value="44" id="cvtColor_BGR2Lab">BGR2Lab
      <option value="45" id="cvtColor_RGB2Lab">RGB2Lab
      <option value="50" id="cvtColor_BGR2Luv">BGR2Luv
      <option value="51" id="cvtColor_RGB2Luv">RGB2Luv
      <option value="52" id="cvtColor_BGR2HLS">BGR2HLS
      <option value="53" id="cvtColor_RGB2HLS">RGB2HLS
      <option value="54" id="cvtColor_HSV2BGR">HSV2BGR
      <option value="55" id="cvtColor_HSV2RGB">HSV2RGB
      <option value="56" id="cvtColor_Lab2BGR">Lab2BGR
      <option value="57" id="cvtColor_Lab2RGB">Lab2RGB
      <option value="58" id="cvtColor_Luv2BGR">Luv2BGR
      <option value="59" id="cvtColor_Luv2RGB">Luv2RGB
      <option value="60" id="cvtColor_HLS2BGR">HLS2BGR
      <option value="61" id="cvtColor_HLS2RGB">HLS2RGB
      <option value="66" id="cvtColor_BGR2HSV_FULL">BGR2HSV_FULL
      <option value="67" id="cvtColor_RGB2HSV_FULL">RGB2HSV_FULL
      <option value="68" id="cvtColor_BGR2HLS_FULL">BGR2HLS_FULL
      <option value="69" id="cvtColor_RGB2HLS_FULL">RGB2HLS_FULL
      <option value="70" id="cvtColor_HSV2BGR_FULL">HSV2BGR_FULL
      <option value="71" id="cvtColor_HSV2RGB_FULL">HSV2RGB_FULL
      <option value="72" id="cvtColor_HLS2BGR_FULL">HLS2BGR_FULL
      <option value="73" id="cvtColor_HLS2RGB_FULL">HLS2RGB_FULL
      <option value="74" id="cvtColor_LBGR2Lab">LBGR2Lab
      <option value="75" id="cvtColor_LRGB2Lab">LRGB2Lab
      <option value="76" id="cvtColor_LBGR2Luv">LBGR2Luv
      <option value="77" id="cvtColor_LRGB2Luv">LRGB2Luv
      <option value="78" id="cvtColor_Lab2LBGR">Lab2LBGR
      <option value="79" id="cvtColor_Lab2LRGB">Lab2LRGB
      <option value="80" id="cvtColor_Luv2LBGR">Luv2LBGR
      <option value="81" id="cvtColor_Luv2LRGB">Luv2LRGB
      <option value="82" id="cvtColor_BGR2YUV">BGR2YUV
      <option value="83" id="cvtColor_RGB2YUV">RGB2YUV
      <option value="84" id="cvtColor_YUV2BGR">YUV2BGR
      <option value="85" id="cvtColor_YUV2RGB">YUV2RGB
      <option value="46" id="cvtColor_BayerBG2BGR">BayerBG2BGR
      <option value="47" id="cvtColor_BayerGB2BGR">BayerGB2BGR
      <option value="48" id="cvtColor_BayerRG2BGR">BayerRG2BGR
      <option value="49" id="cvtColor_BayerGR2BGR">BayerGR2BGR
      <option value="86" id="cvtColor_BayerBG2GRAY">BayerBG2GRAY
      <option value="87" id="cvtColor_BayerGB2GRAY">BayerGB2GRAY
      <option value="88" id="cvtColor_BayerRG2GRAY">BayerRG2GRAY
      <option value="89" id="cvtColor_BayerGR2GRAY">BayerGR2GRAY
    </select>
  </div>
</script>

<script type="text/html" data-help-name="change color space">
<p>Converts an image from one color space to another. </p>
<h3>Inputs</h3>
  <ul><li>payload [img] </ul>
<h3>Outputs</h3>
  <ul><li>payload [img] </ul>
<h3>Arguments</h3>
  <ul><li>conversion code </ul>
<h3>References</h3>
  <ul>
    <li><a href="https://docs.opencv.org/3.4/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab">
      OpenCV docs</a> - full description of the function</li>
  </ul>
</script>


<!--tuneHSV-->
<script type="text/javascript">
  RED.nodes.registerType('tune hsv',{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      ch: {value: "h"},
      multiply: {value: "1"},
      addi: {value: "0"},
      modulo: {value: false}
    },
    inputs:1,
    inputLabels: "colored img",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"tune hsv";
    }
  });
</script>

<!--tuneHSV-->
<script type="text/html" data-template-name="tune hsv">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-ch"><i class="fa fa-tag"></i> channel</label>
    <select id="node-input-ch">
      <option value="h">Hue</option>
      <option value="s">Saturation</option>
      <option value="v">Value</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-multiply"><i class="fa fa-tag"></i> Multiply by</label>
    <input type="number" id="node-input-multiply" step=0.1>
  </div>
  <div class="form-row">
    <label for="node-input-addi"><i class="fa fa-tag"></i> Add</label>
    <input type="number" id="node-input-addi">
  </div>
  <div class="form-row">
    <label for="node-input-modulo"><i class="fa fa-tag"></i> Modulo</label>
    <input type="checkbox" id="node-input-modulo">
  </div>
</script>

<script type="text/html" data-help-name="tune hsv">
  <p> Adjusts the HSV values, by mutiplying by a value, adding a value, and if
    wanted, to clip at 255, use module = true.
  </p>
</script>


<!--minMaxPoints-->
<script type="text/javascript">
  RED.nodes.registerType('get min max location',{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      getMin: {value: false},
      multiPoints: {value: false},
      threshold: {value: "0.9"}
    },
    inputs:1,
    inputLabels: "img",
    outputs:1,
    outputLabels: "",
    icon: "",
    label: function() {
      return this.name||"get min max location";
    },
    oneditprepare: function(){
      multipointsMinMaxPointsHandler(document.getElementById('node-input-multiPoints').value);
    }
  });
</script>

<script type="text/javascript">
  function multipointsMinMaxPointsHandler(val){
    document.getElementById('node-input-threshold').parentElement.hidden = !val;
  }
</script>

<!--minMaxPoints-->
<script type="text/html" data-template-name="get min max location">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-getMin"><i class="fa fa-tag"></i> get min</label>
    <input type="checkbox" id="node-input-getMin">
  </div>
  <div class="form-row">
    <label for="node-input-multiPoints"><i class="fa fa-tag"></i> multiple points</label>
    <input type="checkbox" id="node-input-multiPoints" oninput="multipointsMinMaxPointsHandler(this.checked)">
  </div>
  <div class="form-row">
    <label for="node-input-threshold"><i class="fa fa-tag"></i> threshold</label>
    <input type="number" id="node-input-threshold" min=0>
  </div>
</script>

<script type="text/html" data-help-name="get min max location">
  <p> Finds the positions of the global extrema in a probMatrix, or the positions
    of the points that are above a threshold.
  </p>
  <h3>Inputs</h3>
    <ul><li>payload [probMatr] </ul>
  <h3>Outputs</h3>
    <ol><li>payload [points] </ol>
  <h3>Arguments</h3>
  <ol>
    <li>getMin [bool]: Minimum or maximum points
    <li>multiPoints [bool]: Global min/max or below/above a threshold
    <li>threshold [float]: Should be in the interval [0,1]
  </ol>
</script>

<!--morphTransform-->
<script type="text/javascript">
  RED.nodes.registerType('morphological transform',{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      kernelSize: {value: "3"},
      kernelShape: {value: "0"},
      which: {value: ""},
      iterationNum: {value: "1"}
    },
    inputs:1,
    inputLabels: "img",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"morphological transform";
    }
  });
</script>

<!--morphTransform-->
<script type="text/html" data-template-name="morphological transform">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-kernelSize"><i class="fa fa-tag"></i> Kernel size</label>
    <input type="number" id="node-input-kernelSize" min=1>
  </div>
  <div class="form-row">
    <label for="node-input-kernelShape"><i class="fa fa-tag"></i> Kernel shape</label>
    <select id="node-input-kernelShape">
      <option value="0">RECT</option>
      <option value="1">CROSS</option>
      <option value="2">ELLIPSE</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-which"><i class="fa fa-tag"></i> Transformation</label>
    <select id="node-input-which">
      <option value="0">Erosion</option>
      <option value="1">Dilation</option>
      <option value="2">Opening</option>
      <option value="3">Closing</option>
      <option value="4">Morphological Gradient</option>
      <option value="5">Top Hat</option>
      <option value="6">Black Hat</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-iterationNum"><i class="fa fa-tag"></i> Iterations</label>
    <input type="number" id="node-input-iterationNum" min=1>
  </div>
</script>

<script type="text/html" data-help-name="morphological transform">
  <p> Performs a morphological transformation to a grayscale image (erosion,
    dilation and combinations of them).
  <p>Note: The number of iterations refers to erosions and dilations. Ie. an opening with 2 iterations
  will do erode -> erode -> dilate -> dilate; and not erode -> dilate -> erode -> dilate. </p>

<h3>Inputs</h3>
  <ul><li>payload [img] </ul>
<h3>Outputs</h3>
  <ol><li>payload [img] </ol>
<h3>Arguments</h3>
<ol>
  <li>kernelSize: Structuring element dimensions. For simplicity it's the same
    in both dimensions. Eg kernelSize = 5, would actually mean (5,5).
  <li>kernelShape:  Structuring element shape
  <li>transformation
  <li>iterations: Number of iterations, reffering to erosions and dilations.
</ol>
<h3>References</h3>
  <a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc"> Structuring element - OpenCV docs</a>
  <a></a>
</script>


<!--thresholding-->
<script type="text/javascript">
  RED.nodes.registerType('thresholding',{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      threshType: {value: "0"},
      threshSubtype: {value: "0"},
      adaptiveMethod: {value: "0"},
      thresh: {value: "127"},
      maxVal: {value: "255"},
      blockSize: {value: "11"},
      const: {value: "0"}
    },
    inputs:1,
    inputLabels: "img",
    outputs:1,
    outputLabels: "",
    icon: "",
    label: function() {
      return this.name||"thresholding";
    },
    oneditprepare: function(){
      threshTypeHandler(document.getElementById('node-input-threshType').value);
      threshSubtypeHandler(document.getElementById('node-input-threshSubtype').value);
    }
  });
</script>

<script type="text/javascript">
  function threshTypeHandler(val){

    if (val == "0"){  //simple_thresholding
      document.getElementById('node-input-threshSubtype').parentElement.hidden = false;
      for (let i = 2; i <= 4; i++) {
        document.getElementById('node-input-threshSubtype').options[i].hidden=false;
      }
      document.getElementById('node-input-thresh').parentElement.hidden = false;

      document.getElementById('node-input-adaptiveMethod').parentElement.hidden = true;
      document.getElementById('node-input-blockSize').parentElement.hidden = true;
      document.getElementById('node-input-const').parentElement.hidden = true;


    }else if (val == "1") { //adaptive_thresholding
      document.getElementById('node-input-threshSubtype').parentElement.hidden = false;
      document.getElementById('node-input-adaptiveMethod').parentElement.hidden = false;
      document.getElementById('node-input-blockSize').parentElement.hidden = false;
      document.getElementById('node-input-const').parentElement.hidden = false;

      document.getElementById('node-input-thresh').parentElement.hidden = true;
      for (let i = 2; i <= 4; i++) {
        document.getElementById('node-input-threshSubtype').options[i].hidden=true;
      }


    }else if (val == "2"){  //otsu_s_thresholding
      document.getElementById('node-input-threshSubtype').parentElement.hidden = false;
      for (let i = 2; i <= 4; i++) {
        document.getElementById('node-input-threshSubtype').options[i].hidden=false;
      }

      document.getElementById('node-input-adaptiveMethod').parentElement.hidden = true;
      document.getElementById('node-input-thresh').parentElement.hidden = true;
      document.getElementById('node-input-blockSize').parentElement.hidden = true;
      document.getElementById('node-input-const').parentElement.hidden = true;
    }
  }

  function threshSubtypeHandler(val){
    if (val == "0" || val == "1") { //BINARY or BINARY_INV
      document.getElementById('node-input-maxVal').parentElement.hidden = false;

    } else {
      document.getElementById('node-input-maxVal').parentElement.hidden = true;
    }
  }
</script>

<!--thresholding-->
<script type="text/html" data-template-name="thresholding">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-threshType"><i class="fa fa-tag"></i> Threshold type</label>
    <select id="node-input-threshType" oninput="threshTypeHandler(this.value)">
      <option value="0">simple_thresholding</option>
      <option value="1">adaptive_thresholding</option>
      <option value="2">otsu_s_thresholding</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-threshSubtype"><i class="fa fa-tag"></i> Threshold subtype</label>
    <select id="node-input-threshSubtype" oninput="threshSubtypeHandler(this.value)">
      <option value="0">BINARY</option>
      <option value="1">BINARY_INV</option>
      <option value="2">TRUNC</option>
      <option value="3">TOZERO</option>
      <option value="4">TOZERO_INV</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-adaptiveMethod"><i class="fa fa-tag"></i> Adaptive method</label>
    <select id="node-input-adaptiveMethod">
      <option value="0">MEAN_C</option>
      <option value="1">GAUSSIAN_C</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-thresh"><i class="fa fa-tag"></i> Threshold value</label>
    <input type="number" id="node-input-thresh" min=0 max=255>
  </div>
  <!--only for 8bit img, for 32 bit other. TODO fixme. Only simple thr accepts 32 bits-->
  <div class="form-row">
    <label for="node-input-maxVal"><i class="fa fa-tag"></i> Max value</label>
    <input type="number" id="node-input-maxVal" min=0 max=255>
  </div>
  <div class="form-row">
    <label for="node-input-blockSize"><i class="fa fa-tag"></i> Block size</label>
    <input type="number" id="node-input-blockSize" min=3 step =2>
  </div>
  <div class="form-row">
    <label for="node-input-const"><i class="fa fa-tag"></i> Constant</label>
    <input type="number" id="node-input-const" min=0>
  </div>
</script>

<script type="text/html" data-help-name="thresholding">
  <p> Applies a simple or adaptive threshold to an input image or probMatr. </p>
  <h3>Inputs</h3>
    <ul><li>payload [img or probMatr]</ul>
  <h3>Outputs</h3>
    <ol><li>payload .... todo </ol>
</script>


<!-- split -->
<script type="text/javascript">
  RED.nodes.registerType("split image",{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},

    },
    inputs:1,
    inputLabels: "img",
    outputs:3,
    outputLabels: ["ch1", "ch2", "ch3"],
    icon: "",
    label: function() {
      return this.name||"split image";
    }
  });
</script>

<!-- split -->
<script type="text/html" data-template-name="split image">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
</script>

<script type="text/html" data-help-name="split image">
  <p> Split is used to split coloured/multi-channel image into separate
    single-channel images.
  </p>

</script>


<!-- merge -->
<script type="text/javascript">
  RED.nodes.registerType("merge image",{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},

    },
    inputs:1,
    inputLabels: "",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"merge image";
    }
  });
</script>

<!-- merge -->
<script type="text/html" data-template-name="merge image">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div style="background: var(--red-ui-form-tips-background, #ffe);border-radius: 2px;border: 1px solid var(--red-ui-secondary-border-color, #ddd);">
    Expected keys for the input message:
    <ul>
      <li>?: ch_0</li>
      <li>?: ch_1</li>
      <li>?: ch_2</li>
    </ul>
  </div>
</script>

<script type="text/html" data-help-name="merge image">
  <p> Merge is used to merge several single-channel images into a
    colored/multi-channel image.
  </p>
</script>


<!-- add -->
<script type="text/javascript">
  RED.nodes.registerType("add image",{
    category: 'arithmetic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},

    },
    inputs:1,
    inputLabels: "img_1, img_2",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"add image";
    }
  });
</script>

<!-- add -->
<script type="text/html" data-template-name="add image">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div style="background: var(--red-ui-form-tips-background, #ffe);border-radius: 2px;border: 1px solid var(--red-ui-secondary-border-color, #ddd);">
    Expected keys for the input message:
    <ul>
      <li>Image 1: img_1</li>
      <li>Image 2: img_2</li>
    </ul>
  </div>
</script>

<script type="text/html" data-help-name="add image">
  <p> Calculates the per-element sum of two arrays or an array and a scalar.
  </p>
</script>


<!-- addWeighted -->
<script type="text/javascript">
  RED.nodes.registerType("add weighted image",{
    category: 'arithmetic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      alpha: {value: "0.5"},
      beta: {value: "0.5"},
      gamma: {value: "0"}
    },
    inputs:1,
    inputLabels: "img_1, img_2",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"add weighted image";
    }
  });
</script>

<!-- addWeighted -->
<script type="text/html" data-template-name="add weighted image">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-alpha"><i class="fa fa-tag"></i> alpha</label>
    <input type="number" id="node-input-alpha" min=0 step=0.1>
  </div>
  <div class="form-row">
    <label for="node-input-beta"><i class="fa fa-tag"></i> beta</label>
    <input type="number" id="node-input-beta" min=0 step=0.1>
  </div>
  <div class="form-row">
    <label for="node-input-gamma"><i class="fa fa-tag"></i> gamma</label>
    <input type="number" id="node-input-gamma" min=0 step=0.1>
  </div>
  <div style="background: var(--red-ui-form-tips-background, #ffe);border-radius: 2px;border: 1px solid var(--red-ui-secondary-border-color, #ddd);">
    Expected keys for the input message:
    <ul>
      <li>Image 1: img_1</li>
      <li>Image 2: img_2</li>
    </ul>
  </div>
</script>

<script type="text/html" data-help-name="add weighted image">
  <p> Calculates the weighted sum of two arrays.
    The function addWeighted calculates the weighted sum of two arrays as follows:
    dst = saturate( a*img1 + b*img2 + c )
  </p>
</script>


<!-- subtract -->
<script type="text/javascript">
  RED.nodes.registerType("subtract image",{
    category: 'arithmetic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},

    },
    inputs:1,
    inputLabels: "img_1, img_2",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"subtract image";
    }
  });
</script>

<!-- subtract -->
<script type="text/html" data-template-name="subtract image">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div style="background: var(--red-ui-form-tips-background, #ffe);border-radius: 2px;border: 1px solid var(--red-ui-secondary-border-color, #ddd);">
    Expected keys for the input message:
    <ul>
      <li>Image 1: img_1</li>
      <li>Image 2: img_2</li>
    </ul>
  </div>
</script>

<script type="text/html" data-help-name="subtract image">
  <p> Calculates the per-element difference between two arrays or array and a scalar.
  </p>
</script>


<!-- compare -->
<script type="text/javascript">
  RED.nodes.registerType("compare image",{
    category: 'arithmetic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      method: {value:"diff"},
      tileSizeX: {value:"8"},
      tileSizeY: {value:"8"}
    },
    inputs:1,
    inputLabels: "img_1, img_2",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"compare image";
    },
    oneditprepare: function(){
      handleMethodSelectCompare(document.getElementById('node-input-method').value);
    }
  });

  function handleMethodSelectCompare(val){
    document.getElementById('node-input-tileSizeX').parentElement.hidden = (val != "checkerboard");
    document.getElementById('node-input-tileSizeY').parentElement.hidden = (val != "checkerboard");
  }
</script>

<!-- compare -->
<script type="text/html" data-template-name="compare image">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-method"><i class="fa fa-tag"></i> Method</label>
    <select id="node-input-method" oninput="handleMethodSelectCompare(this.value)">
      <option value="diff">diff</option>
      <option value="blend">blend</option>
      <option value="checkerboard">checkerboard</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-tileSizeX"><i class="fa fa-tag"></i> tileSizeX</label>
    <input type="number" id="node-input-tileSizeX" min=2 step=1>
  </div>
  <div class="form-row">
    <label for="node-input-tileSizeY"><i class="fa fa-tag"></i> tileSizeY</label>
    <input type="number" id="node-input-tileSizeY" min=2 step=1>
  </div>
  <div style="background: var(--red-ui-form-tips-background, #ffe);border-radius: 2px;border: 1px solid var(--red-ui-secondary-border-color, #ddd);">
    Expected keys for the input message:
    <ul>
      <li>Image 1: img_1</li>
      <li>Image 2: img_2</li>
    </ul>
  </div>
</script>

<script type="text/html" data-help-name="compare image">
  <p>
    Return an image showing the differences between two images.
  </p>
  <p>
    'diff' computes the absolute difference between the two images.
    'blend' computes the mean value.
    'checkerboard' makes tiles of dimension n_tiles that display alternatively the first and the second image.
  </p>
</script>


<!-- multiply -->
<script type="text/javascript">
  RED.nodes.registerType("multiply image",{
    category: 'arithmetic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      scale: {value: "1"}
    },
    inputs:1,
    inputLabels: "",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"multiply image";
    }
  });
</script>

<!-- multiply -->
<script type="text/html" data-template-name="multiply image">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-scale"><i class="fa fa-tag"></i> scale</label>
    <input type="number" id="node-input-scale" min=0 step=0.1>
  </div>
  <div style="background: var(--red-ui-form-tips-background, #ffe);border-radius: 2px;border: 1px solid var(--red-ui-secondary-border-color, #ddd);">
    If 2 images are given, txpected keys for the input message are:
    <ul>
      <li>Image 1: img_1</li>
      <li>Image 2: img_2</li>
    </ul>
    Else no renaming is needed.
  </div>
</script>

<script type="text/html" data-help-name="multiply image">
  <p> Multiplies per-element two images or a probMatr and an image.
  </p>
</script>


<!-- resize -->
<script type="text/javascript">
  RED.nodes.registerType("resize image",{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      dsize_cols: {value: "0"},
      dsize_rows: {value: "0"},
      fx: {value: "1"},
      fy: {value: "1"}
    },
    inputs:1,
    inputLabels: "img",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"resize image";
    }
  });
</script>


<!-- affine transform - 3 parts: resize, rotation, addOffsetOrCrop -->
<!-- resize -->
<script type="text/html" data-template-name="resize image">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-dsize_cols"><i class="fa fa-tag"></i> Destination width</label>
    <input type="number" id="node-input-dsize_cols" min=0>
  </div>
  <div class="form-row">
    <label for="node-input-dsize_rows"><i class="fa fa-tag"></i> Destination height</label>
    <input type="number" id="node-input-dsize_rows" min=0>
  </div>
  <div class="form-row">
    <label for="node-input-fx"><i class="fa fa-tag"></i> Scale x</label>
    <input type="number" id="node-input-fx" min=0 step=0.1>
  </div>
  <div class="form-row">
    <label for="node-input-fy"><i class="fa fa-tag"></i> Scale y</label>
    <input type="number" id="node-input-fy" min=0 step=0.1>
  </div>
  <div class="form-row">
    <label for="node-input-interpolationMode"><i class="fa fa-tag"></i> Interpolation mode</label>
    <select id="node-input-interpolationMode">
      <option value="0">INTER_NEAREST</option>
      <option value="1">INTER_LINEAR</option>
      <option value="2">INTER_CUBIC</option>
      <option value="3">INTER_AREA</option>
      <option value="4">INTER_LANCZOS4</option>
    </select>
  </div>
</script>

<script type="text/html" data-help-name="resize image">
  <p>Scale an image up or down. Either by a given factor, or to given destination dimensions.
  </p>
  <p>If scaleX or scaleY is zero, the image will be resized to fit the dimensions given. If the dimensions
    are zero, the image will be scaled by scaleX and Y. Either the scales or the dimensions must be non-zero.
    If both are non-zero, the image will be cropped or filled with black. TODO verify this
  <h3>Inputs</h3>
  <ul>
    <li>payload or payload.img : The image to be resized
    <li>payload.dimensions : Optional. The desired dimensions. Alternatively can be set as arguments.
  </ul>
<h3>Arguments</h3>
  <ul>
    <li>Destination width, height [int]. Alternatively can be set in the input msg.payload
    <li>Scale x and y [float]
    <li>Interpolation mode: For shrinking an image, it will generally look best with INTER_AREA
      interpolation, whereas for enlarging, it will generally look best with INTER_CUBIC or INTER_LINEAR.
  </ul>
<h3>Outputs</h3>
  <ul><li>payload [img] </ul>
<h3>References</h3>
  <ul>
    <li><a href="https://docs.opencv.org/4.x/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d">
      OpenCV docs</a> - full description of the function</li>
  </ul>
</script>

<!-- rotation -->
<script type="text/javascript">
  RED.nodes.registerType("rotation",{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      rotCenterX: {value: "50"},
      rotCenterY: {value: "50"},
      rotAngle: {value: "0"},
      dimsPercent: {value: true},
      destDimsSame: {value: true},
      destDimsX: {value: ""},
      destDimsX: {value: ""}
    },
    inputs:1,
    inputLabels: "",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"rotation";
    },
    oneditprepare: function(){
      handleDestDimsSameRotation(document.getElementById('node-input-destDimsSame').checked);
    }
  });
  function handleDestDimsSameRotation(val){
    document.getElementById('node-input-destDimsX').parentElement.hidden = !!val;
    document.getElementById('node-input-destDimsY').parentElement.hidden = !!val;
  }
</script>

<!-- rotation -->
<script type="text/html" data-template-name="rotation">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-rotCenterX"><i class="fa fa-tag"></i> rotCenterX</label>
    <input type="number" id="node-input-rotCenterX" min=0>
  </div>
  <div class="form-row">
    <label for="node-input-rotCenterY"><i class="fa fa-tag"></i> rotCenterY</label>
    <input type="number" id="node-input-rotCenterY" min=0>
  </div>
  <div class="form-row">
    <label for="node-input-rotAngle"><i class="fa fa-tag"></i> rotAngle</label>
    <input type="number" id="node-input-rotAngle" min=0>
  </div>
  <div class="form-row">
    <label for="node-input-dimsPercent"><i class="fa fa-tag"></i> dimsPercent</label>
    <input type="checkbox" id="node-input-dimsPercent">
  </div>
  <div class="form-row">
    <label for="node-input-destDimsSame"><i class="fa fa-tag"></i> keep same destination dimensions</label>
    <input type="checkbox" id="node-input-destDimsSame" oninput="handleDestDimsSameRotation(this.checked)">
  </div>
  <div class="form-row">
    <label for="node-input-destDimsX"><i class="fa fa-tag"></i> Destination width</label>
    <input type="number" id="node-input-destDimsX" min=0>
  </div>
  <div class="form-row">
    <label for="node-input-destDimsY"><i class="fa fa-tag"></i> Destination height</label>
    <input type="number" id="node-input-destDimsY" min=0>
  </div>
</script>

<script type="text/html" data-help-name="rotation">
  <p>destDims only absolute, rotation point absolute or relative
  </p>
</script>


<!-- combineImages -->
<script type="text/javascript">
  RED.nodes.registerType("combine images",{
    category: 'arithmetic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},

    },
    inputs:1,
    inputLabels: "",
    outputs:1,
    outputLabels: "combined img",
    icon: "",
    label: function() {
      return this.name||"combine images";
    }
  });
</script>

<!-- combineImages -->
<script type="text/html" data-template-name="combine images">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div style="background: var(--red-ui-form-tips-background, #ffe);border-radius: 2px;border: 1px solid var(--red-ui-secondary-border-color, #ddd);">
    Expected keys for the input message:
    <ul>
      <li>Image 1: img_1</li>
      <li>Image 2: img_2</li>
      <li>Mask: img_mask</li>
    </ul>
  </div>
</script>

<script type="text/html" data-help-name="combine images">
  <p> Combines 2 images using a mask. Output pixels are from img_0 where mask==0
    and from img_1 elsewhere.
  </p>
</script>


<!-- prepareImgForOverlay -->
<script type="text/javascript">
  RED.nodes.registerType("prepare img for overlay",{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      dest_shape_w: {value: "100"},
      dest_shape_h: {value: "100"},
      left: {value: "0"},
      top: {value: "0"},
      offsetsPercent: {value: false}
    },
    inputs:1,
    inputLabels: "img",
    outputs:1,
    outputLabels: "img",
    icon: "",
    label: function() {
      return this.name||"prepare img for overlay";
    }
  });
</script>

<!-- todo kapoies func pairnoun img.shape apo msg img, edw einai ws number param. Genika theloume apo context h apo msg img?-->
<!-- prepareImgForOverlay -->
<script type="text/html" data-template-name="prepare img for overlay">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-dest_shape_w"><i class="fa fa-tag"></i> destination width</label>
    <input type="number" id="node-input-dest_shape_w" min=1>
  </div>
  <div class="form-row">
    <label for="node-input-dest_shape_h"><i class="fa fa-tag"></i> destination height</label>
    <input type="number" id="node-input-dest_shape_h" min=1>
  <div class="form-row">
    <label for="node-input-left"><i class="fa fa-tag"></i> left offset</label>
    <input type="number" id="node-input-left" step=0.1>
  </div>
  <div class="form-row">
    <label for="node-input-top"><i class="fa fa-tag"></i> top offset</label>
    <input type="number" id="node-input-top" step=0.1>
  </div>
  <div class="form-row">
    <label for="node-input-offsetsPercent"><i class="fa fa-tag"></i> offset are percent</label>
    <input type="checkbox" id="node-input-offsetsPercent">
  </div>
</script>

<script type="text/html" data-help-name="prepare img for overlay">
  <p> TODO
  </p>
</script>


<!-- addOffsetOrCrop -->
<script type="text/javascript">
  RED.nodes.registerType("add offset or crop",{
    category: 'basic operations',
    color: '#ffce30',
    defaults: {
      broker: {value:"", type:"my-mqtt-broker", required:true},
      left: {value: "0"},
      right: {value: "0"},
      top: {value: "0"},
      bot: {value: "0"},
      isGrayscale: {value: false},
      colorVal: {value: "#000000"},
      grayscaleVal: {value: "0"}
    },
    inputs:1,
    inputLabels: "image",
    outputs:1,
    outputLabels: "image",
    icon: "",
    label: function() {
      return this.name||"add offset or crop";
    },
    oneditprepare: function(){
      handleGrayCheckboxAddOffsCrop(document.getElementById('node-input-isGrayscale').checked);
    }
  });
  function handleGrayCheckboxAddOffsCrop(val){
    document.getElementById('node-input-grayscaleVal').parentElement.hidden = !val;
    document.getElementById('node-input-colorVal').parentElement.hidden = !!val;
  }
</script>

<!-- addOffsetOrCrop -->
<script type="text/html" data-template-name="add offset or crop">
  <div class="form-row">
    <label for="node-input-broker"><i class="fa fa-tag"></i> Broker</label>
    <input id="node-input-broker">
  </div>
  <div class="form-row">
    <label for="node-input-left"><i class="fa fa-tag"></i> Left offset</label>
    <input type="number" id="node-input-left">
  </div>
  <div class="form-row">
    <label for="node-input-right"><i class="fa fa-tag"></i> Right offset</label>
    <input type="number" id="node-input-right">
  </div>
  <div class="form-row">
    <label for="node-input-top"><i class="fa fa-tag"></i> Top offset</label>
    <input type="number" id="node-input-top">
  </div>
  <div class="form-row">
    <label for="node-input-bot"><i class="fa fa-tag"></i> Bottom offset</label>
    <input type="number" id="node-input-bot">
  </div>
  <div class="form-row">
    <label for="node-input-isGrayscale"><i class="fa fa-tag"></i> is grayscale</label>
    <input type="checkbox" id="node-input-isGrayscale" oninput="handleGrayCheckboxAddOffsCrop(this.checked)">
  </div>
  <div class="form-row">
    <label for="node-input-colorVal"><i class="fa fa-tag"></i> Color</label>
    <input type="color" id="node-input-colorVal">
  </div>
  <div class="form-row" hidden>
    <label for="node-input-grayscaleVal"><i class="fa fa-tag"></i> Grayscale value</label>
    <input type="number" id="node-input-grayscaleVal" min=0 max=255>
  </div>
</script>

<script type="text/html" data-help-name="add offset or crop">
  <p>If left, right, top, or bot, are > 0, this offset is added to that side.
  If they are &lt;0, the image is cropped that much at that side.
  </p>
</script>
